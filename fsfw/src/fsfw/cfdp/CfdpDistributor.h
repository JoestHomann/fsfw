#ifndef FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_
#define FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_

#include <utility>
#include <vector>

#include "fsfw/cfdp/pdu/PduHeaderReader.h"
#include "fsfw/returnvalues/returnvalue.h"
#include "fsfw/tcdistribution/CfdpPacketChecker.h"
#include "fsfw/tcdistribution/TcDistributorBase.h"
#include "fsfw/tmtcpacket/cfdp/CfdpPacketStored.h"
#include "fsfw/tmtcservices/AcceptsTelecommandsIF.h"
#include "fsfw/tmtcservices/VerificationReporter.h"

struct CfdpDistribCfg {
  CfdpDistribCfg(object_id_t objectId, StorageManagerIF& tcStore, MessageQueueIF* tcQueue)
      : objectId(objectId), tcStore(tcStore), tcQueue(tcQueue) {}

  object_id_t objectId;
  StorageManagerIF& tcStore;
  MessageQueueIF* tcQueue;
};

/**
 * This will be the primary component to perform PDU forwading procedures. This includes forwarding
 * CFDP TC packets to registered source or destination handlers, and forwarding all telemetry
 * generated by them to registered TM sinks.
 * @ingroup tc_distribution
 */
class CfdpDistributor : public TcDistributorBase, public AcceptsTelecommandsIF {
 public:
  /**
   * The ctor passes @c set_apid to the checker class and calls the
   * TcDistribution ctor with a certain object id.
   * @param setApid The APID of this receiving Application.
   * @param setObjectId Object ID of the distributor itself
   * @param setPacketSource Object ID of the source of TC packets.
   * Must implement CcsdsDistributorIF.
   */
  explicit CfdpDistributor(CfdpDistribCfg cfg);

  [[nodiscard]] const char* getName() const override;
  [[nodiscard]] uint32_t getIdentifier() const override;
  [[nodiscard]] MessageQueueId_t getRequestQueue() const override;

  /**
   * Register a new CFDP entity which can receive PDUs.
   * @param address
   * @param tcDest
   * @return
   *  - @c RETURN_FAILED: Entry already exists for the given address
   */
  ReturnValue_t registerTcDestination(const cfdp::EntityId& address, AcceptsTelecommandsIF& tcDest);

 protected:
  struct EntityInfo {
    EntityInfo(cfdp::EntityId id, const char* name, MessageQueueId_t queueId)
        : id(std::move(id)), name(name), queueId(queueId) {}
    cfdp::EntityId id;
    const char* name;
    MessageQueueId_t queueId;
  };
  PduHeaderReader pduReader;
  ReturnValue_t lastTcError = returnvalue::OK;
  ReturnValue_t lastTmError = returnvalue::OK;
  // I don't think a regular OBSW will have more than 1 or 2 of these destinations, so I think
  // it is okay to accept the overhead here
  std::vector<EntityInfo> tcDestinations;
  CfdpDistribCfg cfg;

  ReturnValue_t selectDestination(MessageQueueId_t& destId) override;

 private:
};

#endif /* FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_ */
